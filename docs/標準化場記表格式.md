# BigDipper AI剪輯系統 - 標準化場記表格式

## 核心問題分析

### 當前問題：JSON字串包裝
**問題源頭**: `gemini_mcp_server.py:1368-1377`
```python
try:
    return json.loads(response.text)
except json.JSONDecodeError:
    return {
        "summary": response.text,  # ⚠️ 整個回應被包裝成字串
        "scenes": [],
        "technical_notes": {},
        "production_notes": "原始分析文本格式"
    }
```

**問題表現**:
```json
{
  "summary": "```json\n{\n  \"summary\": \"實際的結構化數據\",\n  \"scenes\": [...]\n}\n```",
  "scenes": [],
  "technical_notes": {},
  "production_notes": "原始分析文本格式"
}
```

## 解決方案：三層標準化格式

### 第一層：AI友好的提示格式

#### 標準提示模板
```
請分析此影片並以標準JSON格式回應，不要使用markdown代碼塊包裝：

{
  "video_metadata": {
    "filename": "string",
    "duration": "MM:SS",
    "file_size": "string",
    "analysis_timestamp": "ISO-8601"
  },
  "content_analysis": {
    "summary": "string - 簡潔的影片內容摘要",
    "main_subjects": ["array", "of", "subjects"],
    "key_events": ["chronological", "events"],
    "emotional_tone": "string"
  },
  "technical_specs": {
    "image_quality": "string - 畫質評估",
    "stability": "string - 穩定性評估", 
    "lighting": "string - 光線條件",
    "audio_quality": "string - 音質評估"
  },
  "drone_performance": {
    "flight_patterns": ["array", "of", "patterns"],
    "altitude_ranges": "string",
    "shooting_techniques": ["array", "of", "techniques"],
    "operator_skill_level": "beginner|intermediate|advanced|expert"
  },
  "scene_breakdown": [
    {
      "sequence_id": "integer",
      "timestamp": "MM:SS-MM:SS",
      "duration": "integer - seconds",
      "description": "string - 場景描述",
      "flight_action": "string - 飛行動作",
      "subjects": ["array", "of", "subjects"],
      "camera_movement": "string",
      "technical_notes": "string",
      "usability_score": "1-10",
      "tags": ["array", "of", "tags"]
    }
  ],
  "production_assessment": {
    "overall_quality": "1-10",
    "editing_potential": "1-10", 
    "story_value": "1-10",
    "improvements": ["array", "of", "suggestions"],
    "retakes": ["array", "of", "retake", "suggestions"],
    "post_production": ["array", "of", "post", "suggestions"]
  }
}

重要：請直接輸出JSON對象，不要使用```json包裝。
```

### 第二層：智能JSON提取器

#### 提取器實作 (`json_extractor.py`)
```python
import re
import json
import logging
from typing import Dict, Any, Optional

class IntelligentJSONExtractor:
    """智能JSON提取器 - 解決Gemini回應的包裝問題"""
    
    def __init__(self):
        self.logger = logging.getLogger("json_extractor")
        
        # JSON區塊檢測模式
        self.json_patterns = [
            r'```json\s*\n(.*?)\n\s*```',  # 標準markdown包裝
            r'```\s*\n(.*?)\n\s*```',      # 通用代碼塊包裝  
            r'{\s*".*?}\s*',               # 直接JSON對象
        ]
    
    def extract_json_from_response(self, response_text: str) -> Dict[str, Any]:
        """
        從Gemini回應中提取JSON數據
        
        Args:
            response_text: Gemini原始回應文本
            
        Returns:
            Dict: 解析後的結構化數據
        """
        
        # 步驟1: 嘗試直接解析
        try:
            return json.loads(response_text.strip())
        except json.JSONDecodeError:
            self.logger.info("Direct parsing failed, trying pattern extraction")
        
        # 步驟2: 模式匹配提取
        for pattern in self.json_patterns:
            matches = re.findall(pattern, response_text, re.DOTALL | re.IGNORECASE)
            for match in matches:
                try:
                    extracted_data = json.loads(match.strip())
                    if self.validate_extracted_data(extracted_data):
                        self.logger.info("Successfully extracted JSON using pattern matching")
                        return extracted_data
                except json.JSONDecodeError:
                    continue
        
        # 步驟3: 智能清理和重試
        cleaned_text = self.clean_response_text(response_text)
        try:
            return json.loads(cleaned_text)
        except json.JSONDecodeError:
            pass
        
        # 步驟4: 回退方案
        self.logger.warning("All extraction methods failed, generating fallback structure")
        return self.generate_fallback_structure(response_text)
    
    def validate_extracted_data(self, data: Dict[str, Any]) -> bool:
        """驗證提取的數據結構"""
        required_fields = ["video_metadata", "content_analysis", "scene_breakdown"]
        return all(field in data for field in required_fields)
    
    def clean_response_text(self, text: str) -> str:
        """清理回應文本，移除多餘的標記"""
        # 移除markdown標記
        text = re.sub(r'```(?:json)?\s*\n', '', text)
        text = re.sub(r'\n\s*```', '', text)
        
        # 移除多餘的換行和空格
        text = re.sub(r'\n+', ' ', text)
        text = re.sub(r'\s+', ' ', text)
        
        return text.strip()
    
    def generate_fallback_structure(self, original_text: str) -> Dict[str, Any]:
        """當所有解析方法失敗時的回退結構"""
        return {
            "video_metadata": {
                "filename": "unknown",
                "analysis_timestamp": "",
                "parsing_status": "failed"
            },
            "content_analysis": {
                "summary": original_text[:500] + "..." if len(original_text) > 500 else original_text,
                "main_subjects": [],
                "key_events": [],
                "emotional_tone": "unknown"
            },
            "technical_specs": {
                "image_quality": "需要重新分析",
                "stability": "需要重新分析",
                "lighting": "需要重新分析",
                "audio_quality": "需要重新分析"
            },
            "drone_performance": {
                "flight_patterns": [],
                "altitude_ranges": "未知",
                "shooting_techniques": [],
                "operator_skill_level": "unknown"
            },
            "scene_breakdown": [],
            "production_assessment": {
                "overall_quality": 0,
                "editing_potential": 0,
                "story_value": 0,
                "improvements": ["需要重新進行分析"],
                "retakes": [],
                "post_production": []
            },
            "_metadata": {
                "extraction_method": "fallback",
                "requires_manual_review": True,
                "original_response_preview": original_text[:200]
            }
        }
```

### 第三層：標準化數據格式

#### 完整數據結構規範

```json
{
  "video_metadata": {
    "filename": "IMG_1176.MOV",
    "duration": "02:36", 
    "file_size": "843.88 MB",
    "analysis_timestamp": "2025-06-29T15:51:24.043077",
    "analysis_version": "2.0",
    "gemini_model": "gemini-2.5-pro"
  },
  "content_analysis": {
    "summary": "一位台灣無人機飛手分享成為職業飛手的經歷，包括訓練過程和比賽經驗",
    "main_subjects": ["無人機飛手", "職業經歷分享", "比賽經驗"],
    "key_events": [
      "2011年首次接觸無人機比賽",
      "父親啟發開始練習", 
      "2016年贏得台灣亞拓杯第一名",
      "獲得廠商簽約成為廠機師"
    ],
    "emotional_tone": "積極正面",
    "narrative_structure": "經歷分享型",
    "target_audience": "無人機愛好者"
  },
  "technical_specs": {
    "image_quality": {
      "resolution": "高清",
      "clarity": "清晰穩定",
      "color_balance": "自然",
      "exposure": "適當",
      "score": 8
    },
    "stability": {
      "camera_shake": "無明顯抖動",
      "gimbal_performance": "良好", 
      "flight_stability": "平穩",
      "score": 8
    },
    "lighting": {
      "conditions": "光線充足",
      "source": "自然光",
      "quality": "良好",
      "shadows": "適中"
    },
    "audio_quality": {
      "clarity": "清晰",
      "background_noise": "低",
      "voice_quality": "良好",
      "score": 7
    }
  },
  "drone_performance": {
    "flight_patterns": ["定點懸停"],
    "altitude_ranges": "低空（估計<5m）",
    "shooting_techniques": ["定點拍攝", "人物訪談"],
    "operator_skill_level": "intermediate",
    "equipment_assessment": {
      "estimated_model": "消費級或專業級無人機",
      "gimbal_present": true,
      "camera_quality": "professional"
    }
  },
  "scene_breakdown": [
    {
      "sequence_id": 1,
      "timestamp": "00:00-02:36",
      "duration": 156,
      "description": "在學校操場進行人物訪談，背景是教學樓和街景",
      "flight_action": "定點懸停",
      "subjects": ["無人機飛手", "學校操場", "教學樓"],
      "camera_movement": "靜止",
      "shot_type": "中景人物訪談",
      "technical_notes": "無人機保持靜止，主要捕捉人物訪談畫面",
      "usability_score": 8,
      "editing_value": "high",
      "tags": ["訪談", "教育場景", "職業分享", "靜態拍攝"]
    }
  ],
  "production_assessment": {
    "overall_quality": 8,
    "editing_potential": 7,
    "story_value": 9,
    "technical_merit": 8,
    "creative_value": 6,
    "improvements": [
      "加入B-roll鏡頭，如無人機飛行畫面或比賽場景回顧",
      "嘗試不同拍攝角度，如低角度仰拍或高角度俯拍",
      "加入環境音效增強現場感"
    ],
    "retakes": [],
    "post_production": [
      "添加背景音樂營造氛圍",
      "加入文字說明（時間、地點、人物介紹）",
      "音頻降噪處理提高聲音清晰度",
      "添加字幕方便理解講述內容"
    ],
    "editing_recommendations": {
      "best_use_cases": ["開場介紹", "專家訪談段落", "經驗分享"],
      "sequence_position": "mid-story",
      "transition_suggestions": ["淡入", "交叉溶解"],
      "pacing": "medium"
    }
  },
  "_metadata": {
    "extraction_method": "intelligent_parsing",
    "validation_passed": true,
    "processing_time_ms": 1240,
    "model_confidence": 0.92,
    "requires_manual_review": false
  }
}
```

## 整合實施方案

### 修改BigDipper核心函數

#### 新版 `analyze_single_video()` 函數
```python
async def analyze_single_video(self, video_path: str, detail_level: str = "standard") -> Dict[str, Any]:
    """
    分析單一影片 - 使用智能JSON提取器
    """
    from .json_extractor import IntelligentJSONExtractor
    
    extractor = IntelligentJSONExtractor()
    
    # 構建標準化提示
    prompt = self.build_standardized_prompt(video_path, detail_level)
    
    try:
        # 調用Gemini API
        response = await self.model.generate_content_async(prompt)
        
        # 使用智能提取器解析回應
        structured_data = extractor.extract_json_from_response(response.text)
        
        # 添加元數據
        structured_data["_metadata"]["original_response_length"] = len(response.text)
        structured_data["_metadata"]["analysis_timestamp"] = datetime.now().isoformat()
        
        return structured_data
        
    except Exception as e:
        self.logger.error(f"Analysis failed for {video_path}: {e}")
        return extractor.generate_fallback_structure(f"Error: {str(e)}")

def build_standardized_prompt(self, video_path: str, detail_level: str) -> str:
    """構建標準化分析提示"""
    
    base_prompt = f"""
請分析影片 {video_path} 並以以下標準JSON格式回應。

重要指示：
1. 直接輸出JSON對象，不要使用```json包裝
2. 確保所有欄位都有適當的值
3. 時間戳使用MM:SS格式
4. 分數使用1-10評分標準

輸出格式：
{self.get_json_schema()}

請開始分析：
"""
    
    return base_prompt

def get_json_schema(self) -> str:
    """返回標準JSON Schema"""
    return """
{
  "video_metadata": {
    "filename": "string",
    "duration": "MM:SS",
    "file_size": "string",
    "analysis_timestamp": "ISO-8601"
  },
  "content_analysis": {
    "summary": "string",
    "main_subjects": ["array"],
    "key_events": ["array"],
    "emotional_tone": "string"
  },
  // ... (完整schema如上所述)
}
"""
```

## 向後兼容性保證

### 數據遷移策略
```python
class LegacyDataMigrator:
    """處理舊格式數據的遷移"""
    
    def migrate_legacy_analysis(self, legacy_data: Dict[str, Any]) -> Dict[str, Any]:
        """將舊格式轉換為新標準格式"""
        
        # 檢測是否為字串包裝格式
        if isinstance(legacy_data.get("summary"), str) and "```json" in legacy_data["summary"]:
            return self.extract_from_legacy_wrapper(legacy_data["summary"])
        
        # 檢測是否為簡化格式
        if "scenes" in legacy_data and not "scene_breakdown" in legacy_data:
            return self.upgrade_simple_format(legacy_data)
        
        return legacy_data
    
    def extract_from_legacy_wrapper(self, wrapped_summary: str) -> Dict[str, Any]:
        """從字串包裝中提取實際數據"""
        extractor = IntelligentJSONExtractor()
        return extractor.extract_json_from_response(wrapped_summary)
```

## 品質保證機制

### 數據驗證器
```python
class DataValidator:
    """標準化格式的數據驗證器"""
    
    def validate_analysis_result(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """驗證分析結果的完整性和正確性"""
        
        validation_result = {
            "is_valid": True,
            "warnings": [],
            "errors": [],
            "quality_score": 0
        }
        
        # 必要欄位檢查
        required_fields = [
            "video_metadata", "content_analysis", 
            "technical_specs", "scene_breakdown"
        ]
        
        for field in required_fields:
            if field not in data:
                validation_result["errors"].append(f"Missing required field: {field}")
                validation_result["is_valid"] = False
        
        # 數據質量評估
        validation_result["quality_score"] = self.calculate_quality_score(data)
        
        return validation_result
```

此標準化格式解決了JSON字串包裝問題，建立了AI友好的數據結構，並確保了系統的可靠性和擴展性。